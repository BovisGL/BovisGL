import { Request, Response } from 'express';
import jwt from 'jsonwebtoken';
import { passkeyService } from './passkey.js';
import { adminOps, initDatabase } from './database.js';
import { generateSecureToken, verifyToken } from './jwt.js';
import { logAdminAction, getAdminLogs, formatLogEntries } from '../../logging/index.js';
import { logAuthenticationAttempt, logPasskeyEvent, logSystemEvent } from '../../security/services/securityLogger.js';
import crypto from 'crypto';

const JWT_SECRET = process.env.JWT_SECRET;

if (!JWT_SECRET) {
  console.error('FATAL ERROR: JWT_SECRET environment variable is not set.');
  console.error('Please set a strong, random JWT_SECRET in your environment variables.');
  process.exit(1);
}

// Initialize database on startup
initDatabase().catch(console.error);

// Auth service implementations
export const authService = {
  // Public routes
  getCsrfToken: (req: any, res: Response) => {
    try {
      // The CSRF token is generated by the csurf middleware
      // We just need to return it in the response
      const csrfToken = req.csrfToken();
      res.json({ csrfToken });
    } catch (error) {
      console.error('Error generating CSRF token:', error);
      res.status(500).json({ error: 'Failed to generate CSRF token' });
    }
  },
  
  login: async (req: Request, res: Response) => {
    // Passkey login now handled by dedicated passkey routes
    // This endpoint can be used for fallback or alternative auth methods
    res.json({ 
      message: 'Please use passkey authentication',
      endpoints: {
        getLoginOptions: 'POST /passkey/login/options',
        verifyLogin: 'POST /passkey/login/verify',
        getCrossPlatformOptions: 'POST /passkey/login/cross-platform-options'
      }
    });
  },
  
  logout: (req: Request, res: Response) => {
    try {
      // Clear the auth token cookie
      res.clearCookie('auth_token', {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        path: '/'
      });
      
      res.json({ message: 'Logged out successfully' });
    } catch (error) {
      console.error('Error during logout:', error);
      res.status(500).json({ error: 'Failed to logout' });
    }
  },
  
  // Locked routes
  verifyAuth: async (req: any, res: Response) => {
    try {
      const authToken = req.cookies.auth_token || req.headers.authorization?.replace('Bearer ', '');
      
      if (!authToken) {
        return res.status(401).json({ error: 'No authentication token provided' });
      }

      const user = verifyToken(authToken);
      
      if (!user) {
        return res.status(401).json({ error: 'Invalid or expired token' });
      }

      // Get client IP for logging
      const clientIp = req.ip || req.connection.remoteAddress || 'unknown';

      // SECURITY: Add anti-tampering headers to prevent frontend manipulation
      res.set({
        'X-Auth-Required': 'true',
        'X-Tamper-Protection': 'active',
        'X-Client-Validation': 'server-enforced',
        'Cache-Control': 'no-store, no-cache, must-revalidate, private',
        'Pragma': 'no-cache'
      });

      // Log successful authentication (both old and new logging)
      await logAdminAction(
        user.name,
        'ADMIN_PANEL_ACCESS',
        true,
        clientIp,
        'Admin panel accessed successfully'
      );
      
      // Enhanced security logging
      await logAuthenticationAttempt(true, user.name, clientIp, req.headers['user-agent'], 'Token verification successful');

      // Attach user to request for subsequent middleware
      req.user = user;

      res.json({ 
        success: true, 
        user: {
          id: user.id,
          name: user.name
        },
        // SECURITY: Add server timestamp for client validation
        serverTime: Date.now(),
        authLevel: 'verified'
      });
    } catch (error: any) {
      console.error('Error during authentication:', error);
      
      // Log failed authentication (both old and new logging)
      try {
        const clientIp = req.ip || req.connection.remoteAddress || 'unknown';
        await logAdminAction(
          'Unknown',
          'AUTH_VERIFY',
          false,
          clientIp,
          `Authentication failed: ${error.message}`
        );
        
        // Enhanced security logging
        await logAuthenticationAttempt(false, undefined, clientIp, req.headers['user-agent'], `Authentication failed: ${error.message}`);
      } catch (logError) {
        console.error('Failed to log authentication error:', logError);
      }
      
      res.status(401).json({ error: 'Authentication failed' });
    }
  },
  
  getAdminDevices: async (req: any, res: Response) => {
    try {
      if (!req.user?.id) {
        return res.status(401).json({ error: 'Not authenticated' });
      }

      const devices = await passkeyService.getAdminDevices(req.user.id);
      res.json(devices);
    } catch (error) {
      console.error('Error fetching admin devices:', error);
      res.status(500).json({ error: 'Failed to fetch admin devices' });
    }
  },
  
  checkAdmin: async (req: Request, res: Response) => {
    try {
      const { name } = req.body;
      
      if (!name) {
        return res.status(400).json({ error: 'Name is required' });
      }

      const admin = await adminOps.findByName(name);
      
      res.json({ 
        exists: !!admin,
        admin: admin ? {
          id: admin.id,
          name: admin.name,
          createdAt: admin.created_at,
          lastLogin: admin.last_login
        } : null
      });
    } catch (error) {
      console.error('Error checking admin:', error);
      res.status(500).json({ error: 'Failed to check admin' });
    }
  },
  
  createAdmin: async (req: Request, res: Response) => {
    try {
      const { name } = req.body;
      
      if (!name) {
        return res.status(400).json({ error: 'Name is required' });
      }
      
      // Check if admin already exists
      const existingAdmin = await adminOps.findByName(name);
      if (existingAdmin) {
        return res.status(400).json({ error: 'Admin already exists' });
      }

      const admin = await adminOps.create(name);
      
      res.json({
        success: true,
        admin: {
          id: admin.id,
          name: admin.name,
          createdAt: admin.created_at
        }
      });
    } catch (error) {
      console.error('Error creating admin:', error);
      res.status(500).json({ error: 'Failed to create admin' });
    }
  },
  
  removeCurrentDevice: async (req: any, res: Response) => {
    try {
      if (!req.user?.id) {
        return res.status(401).json({ error: 'Not authenticated' });
      }

      // Remove all credentials for current admin (sign them out)
      const { credentialOps } = await import('./database');
      await credentialOps.deleteByAdminId(req.user.id);

      // Clear the auth cookie
      res.clearCookie('auth_token', {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        path: '/'
      });

      res.json({ success: true, message: 'All devices removed and signed out' });
    } catch (error) {
      console.error('Error removing current device:', error);
      res.status(500).json({ error: 'Failed to remove device' });
    }
  },
  
  // Force quit - terminates all servers and backend (emergency use only)
  forceQuit: async (req: Request, res: Response) => {
    try {
      // Get client IP for logging
      const clientIp = req.ip || req.connection.remoteAddress || 'unknown';
      const currentUser = verifyToken(req.cookies.auth_token || '');
      
      const result = await passkeyService.forceSignoutAll();
      
      // Log successful action
      if (currentUser) {
        await logAdminAction(
          currentUser.name,
          'FORCE_QUIT',
          true,
          clientIp,
          'Force quit all servers and signed out all users'
        );
      }
      
      res.json(result);
    } catch (error: any) {
      console.error('Error during force quit:', error);
      
      // Log failed action
      try {
        const clientIp = req.ip || req.connection.remoteAddress || 'unknown';
        const currentUser = verifyToken(req.cookies.auth_token || '');
        if (currentUser) {
          await logAdminAction(
            currentUser.name,
            'FORCE_QUIT',
            false,
            clientIp,
            `Failed to force quit: ${error.message}`
          );
        }
      } catch (logError) {
        console.error('Failed to log force quit error:', logError);
      }
      
      res.status(500).json({ error: 'Force quit failed' });
    }
  },
  
  // Force signout all users (removes all passkeys)
  forceSignoutAll: async (req: Request, res: Response) => {
    try {
      // Get client IP for logging
      const clientIp = req.ip || req.connection.remoteAddress || 'unknown';
      const currentUser = verifyToken(req.cookies.auth_token || '');
      
      const result = await passkeyService.forceSignoutAll();
      
      // Log successful action
      if (currentUser) {
        await logAdminAction(
          currentUser.name,
          'FORCE_SIGNOUT_ALL',
          true,
          clientIp,
          'Force signed out all users and removed all passkeys'
        );
      }
      
      res.json(result);
    } catch (error: any) {
      console.error('Error during force signout:', error);
      
      // Log failed action
      try {
        const clientIp = req.ip || req.connection.remoteAddress || 'unknown';
        const currentUser = verifyToken(req.cookies.auth_token || '');
        if (currentUser) {
          await logAdminAction(
            currentUser.name,
            'FORCE_SIGNOUT_ALL',
            false,
            clientIp,
            `Failed to force signout all: ${error.message}`
          );
        }
      } catch (logError) {
        console.error('Failed to log force signout error:', logError);
      }
      
      res.status(500).json({ error: 'Force signout failed' });
    }
  },
  
  getAdminLogs: async (req: Request, res: Response) => {
    try {
      const limit = parseInt(req.query.limit as string) || 100;
      const logs = await getAdminLogs(limit);
      res.json(logs);
    } catch (error) {
      console.error('Error fetching admin logs:', error);
      res.status(500).json({ error: 'Failed to fetch admin logs' });
    }
  },
  
  getFormattedAdminLogs: async (req: Request, res: Response) => {
    try {
      const limit = parseInt(req.query.limit as string) || 100;
      const rawLogs = await getAdminLogs(limit);
      const formattedLogs = formatLogEntries(rawLogs);
      
      // Create readable text format
      const formatted = formattedLogs.map(log => {
        const timestamp = new Date(log.timestamp).toLocaleString();
        const details = log.details ? ` - ${log.details}` : '';
        return `[${timestamp}] ${log.adminName} (${log.ip}) - ${log.action}: ${log.status}${details}`;
      }).join('\n');
      
      res.json({
        logs: formattedLogs,
        formatted,
        message: `${formattedLogs.length} log entries retrieved`
      });
    } catch (error) {
      console.error('Error fetching formatted admin logs:', error);
      res.status(500).json({ error: 'Failed to fetch formatted admin logs' });
    }
  },
  
  createAdminInvite: async (req: Request, res: Response) => {
    try {
      const { name } = req.body;
      
      if (!name) {
        return res.status(400).json({ error: 'Name is required' });
      }
      
      // Get client IP for logging
      const clientIp = req.ip || req.connection.remoteAddress || 'unknown';
      
      // Import database operations
      const { inviteOps, adminOps, getDatabase } = await import('./database.js');
      const db = await getDatabase();
      
      // Check if admin already exists
      const existingAdmin = await adminOps.findByName(name);
      
      // Helper: generate a URL-safe base64url invite code (shorter & always URI safe)
      function generateInviteCode(): string {
        // 24 random bytes -> 32 char base64url (approx) without padding
        const raw = crypto.randomBytes(24);
        // Use base64url if available; fallback manual replacement
        let code = raw.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
        // Defensive: ensure only url-safe chars
        code = code.replace(/[^A-Za-z0-9_-]/g, '');
        return code;
      }

      // Generate unique invite code (loop until unique)
      let inviteCode: string;
      while (true) {
        inviteCode = generateInviteCode();
        const existing = await db.get(`SELECT invite_code FROM admin_invites WHERE invite_code = ?`, [inviteCode]);
        if (!existing) break;
      }
      
      // Calculate expiration (24 hours from now)
      const expiresAt = new Date(Date.now() + (24 * 60 * 60 * 1000)).toISOString();
      
      // Insert invite into database
      await db.run(`
        INSERT INTO admin_invites (invite_code, name, expires_at)
        VALUES (?, ?, ?)
      `, [inviteCode, name, expiresAt]);
      
      // Generate the full invite URL
  const inviteUrl = `https://bovisgl.xyz/admin/passkey/invite/${encodeURIComponent(inviteCode)}`;
      
      // Log admin action
      const currentUser = verifyToken(req.cookies.auth_token || '');
      if (currentUser) {
        await logAdminAction(
          currentUser.name,
          'ADMIN_INVITE_CREATE',
          true,
          clientIp,
          `Created invite for ${name} (${existingAdmin ? 'existing' : 'new'} admin)`
        );
      }
      
      res.json({
        success: true,
        invite: {
          code: inviteCode,
          url: inviteUrl,
          name: name,
          expiresAt: expiresAt,
          isExistingAdmin: !!existingAdmin,
          encoding: 'base64url'
        }
      });
    } catch (error: any) {
      console.error('Error creating admin invite:', error);
      
      // Log failed action
      try {
        const clientIp = req.ip || req.connection.remoteAddress || 'unknown';
        const currentUser = verifyToken(req.cookies.auth_token || '');
        if (currentUser) {
          await logAdminAction(
            currentUser.name,
            'CREATE_ADMIN_INVITE',
            false,
            clientIp,
            `Failed to create invite: ${error.message}`
          );
        }
      } catch (logError) {
        console.error('Failed to log invite creation error:', logError);
      }
      
      res.status(500).json({ error: 'Failed to create admin invite' });
    }
  }
}; 